
# 算法Road


---


## 写在刷题之前：
### 准备
- 一个主流编程语言的基础，一个顺手的编程环境，几个可以提供参考的信息源
- 参照labuladong算法路线，工欲善其事必先利其器，摸清网站的用法，例如
	- 使用可视化面板深入了解数据结构[^1]，清除算法的执行流程
### 注意
- 主要是练习核心代码模式（如果为了应付考试or面试的话可以临阵磨枪一下acm模式）
- 参考每日一题的低强度持续模式，不必刻意练习
- 刷题的关键点在于，构建一套你的解题方法论（本站中经常称之为「框架思维」）。
- 主要是练就 *抽象能力* ，如果着迷于个体实例，就无法提取共性

具体的题目没有价值，昙花一现的技巧也没有价值，**成体系、可稳定复现的解题方法论才有价值**。

---

## 刷题：
### 难度分类：
- 简单的题多动手形成肌肉记忆，见到大脑条件反射对应的思路
- 常见的题 -> 从一个模块进行切入（分类），由理论知识点总结出抽象模型，刷的过程中与其他模型创建关联 （常见的技巧： 可视化软件，手绘，抽象）
- 难题：不必死磕，理解别人的解法，参考后记笔记慢慢消化吸收

### 刷题&笔记技巧：
- 刷题：
	- 学会合理运用断点，对尝试的思路进行定位调试
	- 最先提交一个暴力的低效率方式，进而利用算法不断优化，
	- 不需要专门练习，每天保持手感即可。
	- 如果是参考了别人的解法，了解完思路后可以自己进行手动的尝试
	- 在保证持续输入的前提下也要保证输出，算法的思路一定要清晰，
- 笔记
	- 总结多题一解，举一反三的栏目，创建关联库
	- 将算法思想类比生活中的模型，辅助理解
	- 通过口述方式理顺思路，或者教授别人来保证题解的正确可行性

### Alogrithm_Sources：
- 文章
	- 主：labuladong笔记小抄，代码随想录
		- 附加：javaGuide
- 视频
	- b站左程云java算法，acwing-y总，b站灵茶山艾府
		- 海贼胡船长c++（作为参考）
- 刷题
	- leetcode，acwing，或者别人的题单。








---
## 参考的博主：
### 提供的路线：
学完javase的基本操作之后，熟悉集合的基本api，然后了解常见的数据结构的特点，常见的算法策略可以从刷题中逐步了解
反复刷 hot100（leetcode）75（面试浓缩）150 （面试经典）sql50   此时算法层面基本过关。 剑指offer（作为补充）
### 参考的话
东哥（labuladong）
- 算法刷题这个东西，可以理解为一门需要单独训练的技能，和项目经验、工作经历等没有直接关系。所以一般会以你的「刷题经验」来判断是否属于算法初学者。
- 不建议直接开始刷题单，题单的主要作用是复习。我建议学完网站文章之后再去刷题单，用来检验学习效果。
- 起初掌握算法一定思想和框架的正反馈的感受很强，因而趁着这个尽头可以将数据结构和算法这块基础彻底搞定，未来工作后就会省很多麻烦，比如跳槽时算法这块就不用专门花时间准备了，因为解题的框架思维已经形成了，不会退化的。
- 可以多想一想你学的这些算法，这种解决算法问题的框架思维，是否可以运用到实际生活当中？生活中的某些场景，是否可以抽象成一个算法问题？如果你遇到一个实际问题，是否可以通过算法的抽象来用编程方法解决？
- 我希望能够在这个学习的过程中，你能培养出自己勤于动手动脑的能力，最终把这些能力运用到更广泛的领域，时刻保持对新事物的好奇心，永远在路上
- 现在对于技术岗的求职者来说，无论是校招还是社招，无论笔试还是面试，考察算法几乎成了标配。
- 本站实际上就是我总结的一套思维框架，而不是简单的题解堆砌。你把这套方法论学走，才配得上你付出的时间和金钱。在遇到新的题目时，这套方法论可以给你提供切入点，逐步优化，最终写出解法代码

算法的唯一用处就是为了筛选人，实际工作很少用到，占比很少。
算法导论： “劝退导论”，初期不建议参考，中后期带着问题查阅，是一个算法思想的词典
### 暴露的行业内算的现状
# Footnotes

[^1]: ### 数据结构可视化支持的操作

1. **标准库数据结构**
    
    - 正常初始化和操作内置数据结构（数组、哈希表等）
        
2. **单链表**
    
    - `LinkedList.createHead(elems)`：创建单链表
        
    - `LinkedList.createCyclicHead(elems, index)`：创建带环单链表
        
3. **双链表**
    
    - `DLinkedList.createHead(elems)`：创建双链表
        
4. **基于拉链法的哈希表**
    
    - `ChainingHashMap.create(capacity)`：创建哈希表
        
    - `put(key, value)`：添加/更新键值对
        
    - `get(key)`：获取键值
        
    - `remove(key)`：删除键值对
        
    - `getTable()`：获取内部数组
        
    - `getTableIndex(index)`：获取索引处的链表头节点
        
5. **基于线性探查法的哈希表**
    
    - `LinearProbingHashMap.create(capacity)`：创建哈希表
        
    - `put(key, value)`：添加/更新键值对
        
    - `get(key)`：获取键值
        
    - `remove(key)`：删除键值对
        
    - `getTable()`：获取内部数组
        
6. **二叉树**
    
    - `BTree.createRoot(elems)`：按力扣格式创建二叉树
        
    - `BTree.createBSTRoot(elems)`：创建二叉搜索树
        
7. **多叉树**
    
    - `NTree.create(items)`：创建N叉树
        
8. **普通二叉搜索树**
    
    - `BSTMap.create()`：创建二叉搜索树（键值对存储）
        
9. **红黑二叉搜索树**
    
    - `RBTreeMap`类：创建红黑树（键值对存储）
        
10. **二叉堆（优先级队列）**
    
    - 支持`swim()`和`sink()`操作
        
    - `showArray()`：显示底层数组结构
        
11. **线段树**
    
    - `SegementTree.create()`：创建自定义线段树
        
    - `query()`：区间查询
        
    - `update()`：单点更新
        
12. **图结构**
    
    - `Graph`类：创建加权/无权/有向/无向图
        
13. **并查集（Union Find）**
    
    - `UF.createNaive(n)`：普通并查集
        
    - `UF.createWeighted(n)`：权重优化并查集
        
    - `UF.createPathCompression(n)`：路径压缩并查集
        
    - `find(p)`：查找根节点
        
    - `union(p, q)`：合并连通分量
        
    - `connected(p, q)`：判断连通性
        
    - `count()`：返回连通分量数量
        
    - `showArray()`：显示parent数组
        
14. **Trie树/前缀树/字典树**
    
    - `Trie.create()`：创建Trie树
        

### 特殊可视化功能

- **`@visualize`注释系统**：
    
    - `status`：控制递归树节点值（用于DFS/动态规划）
        
    - `choose/unchoose`：控制递归树树枝值（用于回溯算法）
        
    - `bfs`：自动生成BFS穷举树
        
    - `color`：设置节点/元素颜色
        
    - `bind/unbind`：绑定变量到数组索引
        
    - `global`：提升变量作用域
        
    - `hide`：隐藏变量
        
- **`console._log`增强**：
    
    - 按递归深度自动缩进输出
        
    - 点击输出可对齐相同递归层级的日志
        
- **数组可视化模式**：
    
    - `@visualize shape nums rect`：数组转为直方图
        
    - `@visualize shape nums cycle`：恢复圆形显示
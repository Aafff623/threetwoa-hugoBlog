# 🪞 Java 注解与反射

## 一、注解（Annotation）

### 1.1 注解概述

> 💡 注解是 JDK5.0 引入的元数据机制，用于为代码添加额外信息

**注解 vs 注释**：
- 注释：给人看的，编译器会忽略
- 注解：给编译器和其他工具看的，可以被读取和处理

### 1.2 内置注解

```java
// @Override - 检查方法重写
@Override
public String toString() {
    return super.toString();
}

// @Deprecated - 标记过时方法
@Deprecated
public static void oldMethod() {
    System.out.println("过时方法");
}

// @SuppressWarnings - 抑制警告
@SuppressWarnings({"unchecked", "deprecation"})
public void test() {
    List list = new ArrayList(); // 不会产生警告
}
```

### 1.3 元注解（Meta-Annotation）

```java
@Target(ElementType.METHOD) // 注解使用范围：方法
@Retention(RetentionPolicy.RUNTIME) // 注解生命周期：运行时
@Documented // 包含在Javadoc中
@Inherited // 允许子类继承
public @interface MyAnnotation {
    String value() default "";
}
```

### 1.4 自定义注解

```java
// 定义注解
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Table {
    String value(); // 表名
}

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Column {
    String name(); // 列名
    String type(); // 类型
    int length() default 255; // 长度
}

// 使用注解
@Table("user")
public class User {
    @Column(name = "id", type = "int")
    private int id;
    
    @Column(name = "name", type = "varchar", length = 50)
    private String name;
}
```

---

## 二、反射（Reflection）

### 2.1 反射概述

> 🔍 反射允许程序在运行时获取类的完整信息并动态操作对象

**反射核心类**：
- `Class` - 类的元数据
- `Field` - 类的字段
- `Method` - 类的方法  
- `Constructor` - 类的构造器

### 2.2 获取 Class 对象的四种方式

```java
// 1. 通过类名.class
Class<String> clazz1 = String.class;

// 2. 通过对象.getClass()
String str = "hello";
Class<?> clazz2 = str.getClass();

// 3. 通过Class.forName()
Class<?> clazz3 = Class.forName("java.lang.String");

// 4. 基本数据类型的TYPE
Class<Integer> clazz4 = int.TYPE;
```

### 2.3 反射操作类成员

```java
public class ReflectionDemo {
    public static void main(String[] args) throws Exception {
        Class<?> clazz = Class.forName("com.example.User");
        
        // 获取所有字段（包括私有）
        Field[] fields = clazz.getDeclaredFields();
        for (Field field : fields) {
            field.setAccessible(true); // 设置可访问私有字段
            System.out.println("字段: " + field.getName());
        }
        
        // 获取所有方法
        Method[] methods = clazz.getDeclaredMethods();
        for (Method method : methods) {
            System.out.println("方法: " + method.getName());
        }
        
        // 创建实例
        Object instance = clazz.newInstance();
        
        // 调用方法
        Method setNameMethod = clazz.getMethod("setName", String.class);
        setNameMethod.invoke(instance, "张三");
        
        Method getNameMethod = clazz.getMethod("getName");
        String name = (String) getNameMethod.invoke(instance);
        System.out.println("姓名: " + name);
    }
}
```

### 2.4 反射操作泛型

```java
public class GenericDemo {
    public List<String> stringList;
    
    public static void main(String[] args) throws Exception {
        Field field = GenericDemo.class.getField("stringList");
        Type genericType = field.getGenericType();
        
        if (genericType instanceof ParameterizedType) {
            ParameterizedType pt = (ParameterizedType) genericType;
            Type[] actualTypes = pt.getActualTypeArguments();
            System.out.println("泛型类型: " + actualTypes[0]); // class java.lang.String
        }
    }
}
```

---

## 三、注解 + 反射实战：ORM框架

### 3.1 定义ORM注解

```java
// 表注解
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface DBTable {
    String name();
}

// 列注解
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface DBColumn {
    String name();
    String type();
    boolean nullable() default true;
}
```

### 3.2 实体类定义

```java
@DBTable(name = "users")
public class User {
    @DBColumn(name = "id", type = "INT", nullable = false)
    private Integer id;
    
    @DBColumn(name = "username", type = "VARCHAR(50)")
    private String username;
    
    @DBColumn(name = "email", type = "VARCHAR(100)")
    private String email;
    
    // 构造方法、getter、setter省略
}
```

### 3.3 ORM映射工具

```java
public class ORMUtil {
    public static String generateCreateTableSQL(Class<?> clazz) {
        if (!clazz.isAnnotationPresent(DBTable.class)) {
            throw new RuntimeException("类没有@DBTable注解");
        }
        
        DBTable table = clazz.getAnnotation(DBTable.class);
        StringBuilder sql = new StringBuilder();
        sql.append("CREATE TABLE ").append(table.name()).append(" (\n");
        
        Field[] fields = clazz.getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            if (field.isAnnotationPresent(DBColumn.class)) {
                DBColumn column = field.getAnnotation(DBColumn.class);
                sql.append("  ").append(column.name()).append(" ").append(column.type());
                if (!column.nullable()) {
                    sql.append(" NOT NULL");
                }
                if (i < fields.length - 1) {
                    sql.append(",");
                }
                sql.append("\n");
            }
        }
        sql.append(");");
        return sql.toString();
    }
    
    public static void main(String[] args) {
        String sql = generateCreateTableSQL(User.class);
        System.out.println(sql);
    }
}
```

**输出结果**：
```sql
CREATE TABLE users (
  id INT NOT NULL,
  username VARCHAR(50),
  email VARCHAR(100)
);
```

---

## 四、反射性能优化

### 4.1 缓存反射对象

```java
public class ReflectionCache {
    private static final Map<Class<?>, Map<String, Field>> fieldCache = new ConcurrentHashMap<>();
    private static final Map<Class<?>, Map<String, Method>> methodCache = new ConcurrentHashMap<>();
    
    public static Field getField(Class<?> clazz, String fieldName) throws NoSuchFieldException {
        Map<String, Field> fields = fieldCache.computeIfAbsent(clazz, k -> new ConcurrentHashMap<>());
        return fields.computeIfAbsent(fieldName, name -> {
            try {
                Field field = clazz.getDeclaredField(name);
                field.setAccessible(true);
                return field;
            } catch (NoSuchFieldException e) {
                throw new RuntimeException(e);
            }
        });
    }
    
    public static Object getFieldValue(Object obj, String fieldName) throws Exception {
        Field field = getField(obj.getClass(), fieldName);
        return field.get(obj);
    }
}
```

### 4.2 使用 setAccessible 提升性能

```java
public class PerformanceDemo {
    public static void main(String[] args) throws Exception {
        Class<?> clazz = User.class;
        User user = new User();
        Field field = clazz.getDeclaredField("username");
        
        // 禁用访问检查（大幅提升性能）
        field.setAccessible(true);
        
        long start = System.currentTimeMillis();
        for (int i = 0; i < 1000000; i++) {
            field.set(user, "test" + i);
        }
        long end = System.currentTimeMillis();
        System.out.println("耗时: " + (end - start) + "ms");
    }
}
```

---

## 五、总结对比

### 5.1 注解类型总结

| 注解类型 | 作用 | 示例 |
|---------|------|------|
| 内置注解 | Java自带 | `@Override`, `@Deprecated` |
| 元注解 | 注解其他注解 | `@Target`, `@Retention` |
| 自定义注解 | 用户自定义 | `@DBTable`, `@DBColumn` |

### 5.2 反射应用场景

| 场景 | 说明 | 示例 |
|------|------|------|
| 框架开发 | 实现IoC、AOP等 | Spring框架 |
| 动态代理 | 运行时生成代理类 | JDK动态代理 |
| 序列化 | 对象与数据转换 | Jackson, Gson |
| ORM映射 | 对象关系映射 | Hibernate, MyBatis |
| 单元测试 | 动态调用测试方法 | JUnit |

### 5.3 性能考虑

| 操作 | 性能影响 | 建议 |
|------|---------|------|
| 获取Class对象 | 低 | 可缓存 |
| 获取Field/Method | 中 | 可缓存 |
| 调用setAccessible | 一次性开销 | 必要时应使用 |
| 方法调用(invoke) | 高 | 避免频繁调用 |

> 🚀 **最佳实践**：反射虽强大但应谨慎使用，优先考虑接口和抽象类等面向对象的设计方式。在必须使用反射时，注意缓存反射对象和合理使用 `setAccessible(true)` 来提升性能。

---

通过注解和反射，Java 实现了强大的元编程能力，这是很多框架和库的基础。掌握这两项技术，能够更好地理解 Java 生态系统的运行机制，也是进阶高级开发的必备技能。
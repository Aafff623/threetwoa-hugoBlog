
# 🚨 Java异常处理机制

## 一、异常的概念与分类

### 什么是异常？
- 程序运行过程中发生的意外事件，干扰正常指令流程
- 例如：文件找不到、除零操作、空指针访问等

### 异常分类：

| 类型 | 说明 | 示例 |
|------|------|------|
| **Error** | 系统错误，程序无法处理 | `OutOfMemoryError`, `StackOverflowError` |
| **Exception** | 程序可处理的异常 | `IOException`, `SQLException` |
| **RuntimeException** | 运行时异常，可避免 | `NullPointerException`, `ArithmeticException` |

### 检查异常 vs 非检查异常：

| 类型 | 是否必须处理 | 示例 |
|------|-------------|------|
| **Checked Exception** | 是 | `IOException`, `ClassNotFoundException` |
| **Unchecked Exception** | 否 | `NullPointerException`, `ArrayIndexOutOfBoundsException` |

---

## 二、异常处理机制

### 1. 抛出异常（Throw）
- 使用 `throw` 关键字主动抛出异常
- 通常用于方法内部无法处理异常时

```java
throw new IllegalArgumentException("参数错误");
```

### 2. 声明异常（Throws）
- 在方法签名中使用 `throws` 声明可能抛出的异常
- 调用者必须处理或继续抛出

```java
public void readFile(String path) throws IOException {
    // 可能抛出IOException的代码
}
```

### 3. 捕获异常（Try-Catch）
- 使用 `try-catch` 块捕获并处理异常

```java
try {
    // 可能抛出异常的代码
} catch (IOException e) {
    System.out.println("文件读取异常: " + e.getMessage());
}
```

### 4. finally 块
- 无论是否发生异常，finally 块都会执行
- 常用于资源释放（如关闭文件、数据库连接）

```java
try {
    // 可能抛出异常的代码
} catch (Exception e) {
    e.printStackTrace();
} finally {
    // 释放资源
    System.out.println("执行finally块");
}
```

---

## 三、异常处理关键字

| 关键字 | 作用 |
|--------|------|
| `try` | 定义监控区域，捕获可能发生的异常 |
| `catch` | 捕获并处理特定类型的异常 |
| `finally` | 无论是否发生异常，都会执行的代码块 |
| `throw` | 在方法内部抛出异常 |
| `throws` | 在方法声明中指明可能抛出的异常 |

---

## 四、多重 catch 块与嵌套 try

### 多重 catch 块：
```java
try {
    // 可能抛出多种异常的代码
} catch (IOException e) {
    // 处理IO异常
} catch (SQLException e) {
    // 处理SQL异常
} catch (Exception e) {
    // 捕获其他所有异常
}
```

### 嵌套 try 块：
```java
try {
    try {
        // 内部try块
    } catch (Exception e) {
        // 内部异常处理
    }
} catch (Exception e) {
    // 外部异常处理
}
```

---

## 五、自定义异常

### 步骤：
1. 继承 `Exception` 或 `RuntimeException`
2. 提供构造方法
3. 可选重写 `toString()` 或 `getMessage()`

### 示例：
```java
class MyException extends Exception {
    private int detail;

    public MyException(int a) {
        detail = a;
    }

    @Override
    public String toString() {
        return "MyException[" + detail + "]";
    }
}
```

### 使用自定义异常：
```java
public void compute(int value) throws MyException {
    if (value > 100) {
        throw new MyException(value);
    }
}
```

---

## 六、异常处理最佳实践 ✅

1. **精准捕获**：尽量捕获具体异常，而不是一概用 `Exception`
2. **避免空 catch**：不要忽略异常，至少打印日志
3. **资源释放**：使用 `finally` 或 try-with-resources 释放资源
4. **异常链**：保留原始异常信息，便于调试
5. **自定义异常**：为业务逻辑定义有意义的异常类
6. **日志记录**：使用日志框架记录异常，而非仅 `printStackTrace()`

---

## 七、常见异常示例

| 异常类型 | 说明 | 示例代码 |
|----------|------|----------|
| `NullPointerException` | 空指针异常 | `String s = null; s.length();` |
| `ArithmeticException` | 算术异常 | `int a = 10 / 0;` |
| `ArrayIndexOutOfBoundsException` | 数组越界 | `int[] arr = new int[1]; arr[1] = 0;` |
| `ClassNotFoundException` | 类未找到 | `Class.forName("com.xxx.NonexistentClass");` |
| `IOException` | 输入输出异常 | `new FileInputStream("nonexistent.txt");` |

---

## 八、总结

| 概念 | 说明 |
|------|------|
| **异常分类** | Error、Exception、RuntimeException |
| **处理方式** | try-catch-finally、throw、throws |
| **自定义异常** | 继承Exception，提供有意义的异常信息 |
| **最佳实践** | 精准捕获、资源释放、日志记录 |
| **常见异常** | NPE、除零、数组越界等 |
